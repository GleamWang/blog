/*
SQLyog Ultimate v13.1.1 (64 bit)
MySQL - 8.0.25 : Database - blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`blog` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `blog`;

/*Table structure for table `animation` */

DROP TABLE IF EXISTS `animation`;

CREATE TABLE `animation` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `time` date DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=113 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

/*Data for the table `animation` */

insert  into `animation`(`id`,`name`,`time`) values 
(1,'缘之空',NULL),
(2,'某科学的超电磁炮1&2',NULL),
(3,'未闻花名',NULL),
(4,'樱花庄的宠物女孩',NULL),
(5,'刀剑神域1&2&3',NULL),
(6,'五等分',NULL),
(7,'俺妹1',NULL),
(8,'埃罗芒阿老师',NULL),
(9,'魔法禁书目录1',NULL),
(10,'辉夜大小姐想让我告白',NULL),
(11,'刀剑神域:序列之争',NULL),
(12,'你的名字',NULL),
(13,'我想吃掉你的胰脏',NULL),
(14,'朝花夕誓',NULL),
(15,'夏目友人帐(剧场版)',NULL),
(16,'干物妹小埋1&2','2019-06-24'),
(17,'一个人的○○小日子','2019-06-24'),
(18,'盾之勇者成名录','2019-07-02'),
(19,'Re:从零开始的异世界生活','2019-07-07'),
(20,'关于我转生变成史莱姆这档事','2019-07-10'),
(21,'龙王的工作','2019-07-12'),
(22,'路人女主的养成方法','2019-07-27'),
(23,'来自多彩世界的明天','2019-07-30'),
(24,'月色真美','2019-08-27'),
(25,'jojo不灭钻石','2019-09-06'),
(26,'jojo黄金之风','2019-09-15'),
(27,'调教咖啡厅','2019-09-16'),
(28,'擅长捉弄的高木同学1','2019-09-19'),
(29,'citrus~柑橘的香气~','2019-09-22'),
(30,'擅长捉弄的高木同学2','2019-09-22'),
(31,'天使降临我身边','2019-09-23'),
(32,'鬼灭之刃','2019-09-29'),
(33,'欢迎来到实力至上主义的教室','2019-09-30'),
(34,'Angel of Death','2019-10-06'),
(35,'jojo星辰远征军','2019-10-22'),
(36,'春猪(剧场版)','2019-11-14'),
(37,'jojo的奇妙冒险1&2','2019-12-14'),
(38,'我，不是说了能力要平均值么！','2019-12-23'),
(39,'这个勇者明明超强却过于慎重','2019-12-29'),
(40,'刀剑神域-人界战争（上）','2019-12-29'),
(41,'境界的彼方','2020-01-10'),
(42,'境界的彼方 过去篇&未来篇','2020-01-12'),
(43,'中二病也要谈恋爱','2020-01-15'),
(44,'中二病也要谈恋爱-恋','2020-01-16'),
(45,'中二病也要谈恋爱TOM','2020-01-16'),
(46,'游戏人生','2020-01-19'),
(47,'游戏人生Zero','2020-01-20'),
(48,'一拳超人','2020-01-23'),
(49,'紫罗兰永恒花园','2020-01-31'),
(50,'我女友与青梅竹马的惨烈修罗场','2020-02-06'),
(51,'齐木楠雄的灾难1&2','2020-02-24'),
(52,'齐木楠雄的灾难始动篇','2020-02-25'),
(53,'异度侵入','2020-03-29'),
(54,'地缚少年花子君','2020-04-01'),
(55,'终将成为你','2020-04-03'),
(56,'恋情10厘米 告白实行委员会~','2020-04-04'),
(57,'我的青春恋爱物语果然有问题','2020-04-05'),
(58,'琴浦小姐','2020-04-08'),
(59,'我的青春恋爱物语果然有问题 续','2020-04-08'),
(60,'Charlotte','2020-04-10'),
(61,'徒然喜欢你','2020-04-12'),
(62,'玉子市场','2020-04-15'),
(63,'玉子爱情故事','2020-04-16'),
(64,'overload Ⅱ','2020-04-28'),
(65,'overload Ⅲ','2020-04-29'),
(66,'家有女友','2020-05-14'),
(67,'龙与虎','2020-05-31'),
(68,'RELIFE','2020-06-17'),
(69,'这个美术社大有问题！','2020-06-21'),
(70,'辉夜大小姐想让我告白2','2020-06-29'),
(71,'日在校园','2020-07-08'),
(72,'公主连结Re:Dive','2020-07-08'),
(73,'格莱普尼尔','2020-07-08'),
(74,'点兔','2020-07-19'),
(75,'点兔OVA&剧场版','2020-07-26'),
(76,'One Room','2020-07-29'),
(77,'One Room 2','2020-07-31'),
(78,'伪恋','2020-08-06'),
(79,'进击的巨人','2020-09-05'),
(80,'一周的朋友','2020-09-14'),
(81,'刀剑神域UW篇','2020-09-20'),
(82,'路人女主fine','2020-09-27'),
(83,'我的青春恋爱物语果然有问题 完','2020-09-27'),
(84,'食戟之灵','2020-10-29'),
(85,'食戟之灵 2','2020-11-01'),
(86,'魔女之旅','2020-12-19'),
(87,'One room 3','2020-12-22'),
(88,'点兔3','2020-12-28'),
(89,'安达与岛村','2020-12-29'),
(90,'只有我不存在的城市','2021-02-28'),
(91,'进击的巨人 Season2&3.part1','2021-03-13'),
(92,'租借女友','2021-03-20'),
(93,'进击的巨人 3.part2','2021-03-24'),
(94,'从零开始的异世界生活2','2021-03-24'),
(95,'五等分2','2021-03-26'),
(96,'咒术回战','2021-03-27'),
(97,'进击的巨人 最终季 part.1','2021-03-29'),
(98,'堀与宫村','2021-04-02'),
(99,'回复术士的重启人生','2021-04-07'),
(100,'赛马娘 2','2021-05-23'),
(101,'赛马娘','2021-05-23'),
(102,'赛马娘四格','2021-05-24'),
(103,'摇曳露营','2021-07-31'),
(104,'死神少爷与黑女仆','2021-09-26'),
(105,'鬼灭之刃 无限列车','2021-09-28'),
(106,'Fate stay night UBW 1','2021-10-03'),
(107,'Fate stay night UBW 2','2021-10-04'),
(108,'Fate Heaven\'s feel 1','2021-10-05'),
(109,'Fate Heaven\'s feel 2&3','2021-10-06'),
(110,'Fate Zero 1','2021-10-14'),
(111,'Fate Zero 2','2021-10-20'),
(112,'Fate UBW(剧场版)','2021-10-20');

/*Table structure for table `article` */

DROP TABLE IF EXISTS `article`;

CREATE TABLE `article` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '序号',
  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '标题',
  `content1` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci COMMENT '正文-text',
  `content2` text COLLATE utf8mb4_unicode_ci COMMENT '正文-html',
  `author` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '作者',
  `time1` datetime DEFAULT NULL COMMENT '发布时间',
  `time2` datetime DEFAULT NULL COMMENT '更新时间',
  `category` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '类别',
  `tag` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '标签',
  `img` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '封面地址',
  `original` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '是否原创',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=67 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

/*Data for the table `article` */

insert  into `article`(`id`,`title`,`content1`,`content2`,`author`,`time1`,`time2`,`category`,`tag`,`img`,`original`) values 
(52,'Springboot常用注解','1、@SpringBootApplication包含@Configuration、@EnableAutoConfiguration、@ComponentScan通常用在主类上。2、@Repository用于标注数据访问组件，即DAO组件。3、@Service用于标注业务层组件。4、@RestController用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody5、@ResponseBody表示该方法的返回结果直接写入HTTP response body中一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。6、@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。7、@ComponentScan组件扫描。相当于，如果扫描到有@Component @Controller @Service等这些注解的类，则把这些类注册为bean。8、@Configuration指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上。9、@Bean相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。10、@EnableAutoConfiguration让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上。11、@AutoWiredbyType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。12、@Qualifier当有多个同一类型的Bean时，可以用@Qualifier(\"name\")来指定。与@Autowired配合使用13、@Resource(name=\"name\",type=\"type\")没有括号内内容的话，默认byName。与@Autowired干类似的事。14、@RequestMappingRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：params:指定request中必须包含某些参数值是，才让该方法处理。headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。value:指定请求的实际地址，指定的地址可以是URI Template 模式method:指定请求的method类型， GET、POST、PUT、DELETE等consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回15、@RequestParam用在方法的参数前面。@RequestParam String a =request.getParameter(\"a\")16、@PathVariable路径变量。参数与大括号里的名字一样要相同。RequestMapping(\"user/get/mac/{macAddress}\")\n\npublic String getByMacAddress(@PathVariable String macAddress){\n\n　　//do something;\n\n　　}17、@ProfilesSpring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。@Configuration\n\n@Profile(\"prod\")\n\npublic class ProductionConfiguration { // ...}18、@ConfigurationPropertiesSpring Boot将尝试校验外部的配置，默认使用JSR-303（如果在classpath路径中）。你可以轻松的为你的@ConfigurationProperties类添加JSR-303 javax.validation约束注解：@Component\n\n@ConfigurationProperties(prefix=\"connection\")\n\npublic class ConnectionSettings {\n\n@NotNullprivate InetAddress remoteAddress;\n\n// ... getters and setters\n\n}全局异常处理19、@ControllerAdvice包含@Component。可以被扫描到。统一处理异常20、@ExceptionHandler（Exception.class）用在方法上面表示遇到这个异常就执行以下方法','<p><b>1、@SpringBootApplication</b><br/><br/>包含@Configuration、@EnableAutoConfiguration、@ComponentScan<br/><br/>通常用在主类上。<br/><br/><b>2、@Repository</b><br/><br/>用于标注数据访问组件，即DAO组件。<br/><br/><b>3、@Service</b><br/><br/>用于标注业务层组件。<br/><br/><b>4、@RestController</b><br/><br/>用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody<br/><b><br/>5、@ResponseBody</b><br/><br/>表示该方法的返回结果直接写入HTTP response body中<br/><br/>一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析<br/><br/>为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。<br/><br/><b>6、@Component</b><br/><br/>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。<br/><br/><b>7、@ComponentScan</b><br/><br/>组件扫描。相当于，如果扫描到有@Component @Controller @Service等这些注解的类，则把<br/><br/>这些类注册为bean。<br/><br/><b>8、@Configuration</b><br/><br/>指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上。<br/><br/><b>9、@Bean</b><br/><br/>相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。<br/><br/><b>10、@EnableAutoConfiguration</b><br/><br/>让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上。<br/><br/><b>11、@AutoWired</b><br/><br/>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。<br/>当加上（required=false）时，就算找不到bean也不报错。<br/><br/><b>12、@Qualifier</b><br/><br/>当有多个同一类型的Bean时，可以用@Qualifier(\"name\")来指定。与@Autowired配合使用<br/><br/><b>13、@Resource(name=\"name\",type=\"type\")</b><br/><br/>没有括号内内容的话，默认byName。与@Autowired干类似的事。<br/><br/><b>14、@RequestMapping</b><br/><br/>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br/><br/>该注解有六个属性：<br/><br/>params:指定request中必须包含某些参数值是，才让该方法处理。<br/><br/>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。<br/><br/>value:指定请求的实际地址，指定的地址可以是URI Template 模式<br/><br/>method:指定请求的method类型， GET、POST、PUT、DELETE等<br/><br/>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;<br/><br/>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br/><br/><b>15、@RequestParam</b><br/><br/>用在方法的参数前面。</p><p><br/></p><pre><code class=\"Java\"><xmp>@RequestParam String a =request.getParameter(\"a\")</xmp></code></pre><p><br/><b>16、@PathVariable</b><br/><br/>路径变量。参数与大括号里的名字一样要相同。</p><p><br/></p><pre><code class=\"Java\"><xmp>RequestMapping(\"user/get/mac/{macAddress}\")\n\npublic String getByMacAddress(@PathVariable String macAddress){\n\n　　//do something;\n\n　　}</xmp></code></pre><p><br/><b>17、@Profiles</b><br/><br/>Spring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。<br/><br/>任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。</p><p><br/></p><pre><code class=\"Java\"><xmp>@Configuration\n\n@Profile(\"prod\")\n\npublic class ProductionConfiguration { // ...}</xmp></code></pre><p><br/></p><p><b>18、@ConfigurationProperties</b><br/><br/>Spring Boot将尝试校验外部的配置，默认使用JSR-303（如果在classpath路径中）。<br/><br/>你可以轻松的为你的@ConfigurationProperties类添加JSR-303 javax.validation约束注解：<br/><br/></p><pre><code class=\"Java\"><xmp>@Component\n\n@ConfigurationProperties(prefix=\"connection\")\n\npublic class ConnectionSettings {\n\n@NotNullprivate InetAddress remoteAddress;\n\n// ... getters and setters\n\n}</xmp></code></pre><p><br/>全局异常处理<br/><br/><b>19、</b><b>@ControllerAdvice</b><br/><br/>包含@Component。可以被扫描到。<br/><br/>统一处理异常<br/><br/><b>20、</b><b>@ExceptionHandler（Exception.class）</b><br/><br/>用在方法上面表示遇到这个异常就执行以下方法<br/></p>','Gleam','2021-11-08 14:36:43','2021-11-08 14:36:43','Springboot','Spring,Springmvc,Springboot','http://localhost:9090/article/c13e0c4e131740a1a7aa85df39b44762',NULL),
(53,'MySQL模糊查询','在进行数据库查询时，有完整查询和模糊查询之分。一般模糊查询语句如下：SELECT 字段 FROM 表 WHERE 某字段 Like 条件其中关于条件，SQL提供了四种匹配模式：1，%&nbsp;：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。比如 SELECT * FROM [user] WHERE u_name LIKE \'%三%\'将会把u_name为“张三”，“张猫三”、“三脚猫”，“唐三藏”等等有“三”的记录全找出来。另外，如果需要找出u_name中既有“三”又有“猫”的记录，请使用and条件SELECT * FROM [user] WHERE u_name LIKE \'%三%\' AND u_name LIKE \'%猫%\'若使用 SELECT * FROM [user] WHERE u_name LIKE \'%三%猫%\'虽然能搜索出“三脚猫”，但不能搜索出符合条件的“张猫三”。2，_&nbsp;： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句：比如 SELECT * FROM [user] WHERE u_name LIKE \'_三_\'只找出“唐三藏”这样u_name为三个字且中间一个字是“三”的；再比如 SELECT * FROM [user] WHERE u_name LIKE \'三__\';只找出“三脚猫”这样name为三个字且第一个字是“三”的；3，[ ]&nbsp;：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。比如 SELECT * FROM [user] WHERE u_name LIKE \'[张李王]三\'将找出“张三”、“李三”、“王三”（而不是“张李王三”）；如 [ ] 内有一系列字符（01234、abcde之类的）则可略写为“0-4”、“a-e”SELECT * FROM [user] WHERE u_name LIKE \'老[1-9]\'将找出“老1”、“老2”、……、“老9”；4，[^ ]&nbsp;：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。比如 SELECT * FROM [user] WHERE u_name LIKE \'[^张李王]三\'将找出不姓“张”、“李”、“王”的“赵三”、“孙三”等；SELECT * FROM [user] WHERE u_name LIKE \'老[^1-4]\';将排除“老1”到“老4”，寻找“老5”、“老6”、……5，查询内容包含通配符时由于通配符的缘故，导致我们查询特殊字符“%”、“_”、“[”的语句无法正常实现，而把特殊字符用“[ ]”括起便可正常查询。','<p>在进行数据库查询时，有完整查询和模糊查询之分。<br/><br/>一般模糊查询语句如下：<br/><br/></p><table><tbody><tr><td>SELECT 字段 FROM 表 WHERE 某字段 Like 条件<br/></td></tr></tbody></table><p><br/>其中关于条件，SQL提供了四种匹配模式：<br/><br/><strong>1，%</strong>&nbsp;：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。<br/><br/>比如 SELECT * FROM [user] WHERE u_name LIKE \'%三%\'<br/><br/>将会把u_name为“张三”，“张猫三”、“三脚猫”，“唐三藏”等等有“三”的记录全找出来。<br/><br/>另外，如果需要找出u_name中既有“三”又有“猫”的记录，请使用and条件<br/>SELECT * FROM [user] WHERE u_name LIKE \'%三%\' AND u_name LIKE \'%猫%\'<br/><br/>若使用 SELECT * FROM [user] WHERE u_name LIKE \'%三%猫%\'<br/>虽然能搜索出“三脚猫”，但不能搜索出符合条件的“张猫三”。<br/><br/><strong>2，_</strong>&nbsp;： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句：<br/><br/>比如 SELECT * FROM [user] WHERE u_name LIKE \'_三_\'<br/>只找出“唐三藏”这样u_name为三个字且中间一个字是“三”的；<br/><br/>再比如 SELECT * FROM [user] WHERE u_name LIKE \'三__\';<br/>只找出“三脚猫”这样name为三个字且第一个字是“三”的；<br/><br/><br/><strong>3，[ ]</strong>&nbsp;：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。<br/><br/>比如 SELECT * FROM [user] WHERE u_name LIKE \'[张李王]三\'<br/>将找出“张三”、“李三”、“王三”（而不是“张李王三”）；<br/><br/>如 [ ] 内有一系列字符（01234、abcde之类的）则可略写为“0-4”、“a-e”<br/>SELECT * FROM [user] WHERE u_name LIKE \'老[1-9]\'<br/>将找出“老1”、“老2”、……、“老9”；<br/><br/><strong>4，[^ ]</strong>&nbsp;：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。<br/><br/>比如 SELECT * FROM [user] WHERE u_name LIKE \'[^张李王]三\'<br/>将找出不姓“张”、“李”、“王”的“赵三”、“孙三”等；<br/><br/>SELECT * FROM [user] WHERE u_name LIKE \'老[^1-4]\';<br/>将排除“老1”到“老4”，寻找“老5”、“老6”、……<br/><br/><strong>5，查询内容包含通配符时</strong><br/><br/>由于通配符的缘故，导致我们查询特殊字符“%”、“_”、“[”的语句无法正常实现，而把特殊字符用“[ ]”括起便可正常查询。</p>','Gleam','2021-11-08 14:41:25','2021-11-08 14:41:25','MySQL','MySQL','http://localhost:9090/article/8a9b888641c44292b9411485d8b12584',NULL),
(54,'Linux安装JDK1.8','1.都要做什么?安装1.将安装包上传至Linux服务器2.解压配置环境变量解决版本问题(如本身系统没有装低版本的jdk可将此步骤忽略)2.安装2.1创建两个文件夹1.创建sort      mkdir -p /export/sort    (此目录用来存放安装包)2.创建install   mkdir -p /export/install2.2 使用工具上传至Linux服务器将安装包放入/export/sort文件夹下2.3 解压到install文件夹中tar -zxvf /export/sort/jdk-8u144-linux-x64.tar.gz -C /export/install/3.配置环境变量3.1 编辑文件vim /etc/profile.d/java.sh3.2 将内容复制到文件中按i编辑export JAVA_HOME=/export/install/jdk1.8.0_144export PATH=$PATH:$JAVA_HOME/bin按esc输入:wq 保存并退出3.3 检查是否配置完成输入 jpsjps: command not found表示未成功!3.4 更新profile文件source /etc/profile3.5 重新检查输入jps如果出现数字表示安装成功!2296 Jps4.切换版本(本地已有jdk时操作,没有请忽略!)先查看一下版本java -versionwhereis java查看这个目录ll /usr/bin/java你会发现是一个软链接(类似于Windows的快捷方式)再查看一下ll /etc/alternatives/java你会看到指向的jdk1.7的bin里的java我们将这个软连接删除掉 再重新创建一个新的rm -rf /etc/alternatives/javaln -s /export/install/jdk1.8.0_144/bin/java /etc/alternatives/java再来查看一下版本java -versionOK了!','<p><b>1.都要做什么?</b></p><p>安装<br/>1.将安装包上传至Linux服务器<br/>2.解压<br/>配置环境变量<br/>解决版本问题(如本身系统没有装低版本的jdk可将此步骤忽略)<br/><b><br/></b></p><p><b>2.安装</b></p><p><b>2.1创建两个文件夹</b><br/><code>1.创建sort      mkdir -p /export/sort    (此目录用来存放安装包)</code></p><p><code>2.创建install   mkdir -p /export/install</code></p><p><font face=\"monospace\"><br/></font><b>2.2 使用工具上传至Linux服务器</b><br/>将安装包放入/export/sort文件夹下</p><p><br/><b>2.3 解压到install文件夹中</b><br/><code>tar -zxvf /export/sort/jdk-8u144-linux-x64.tar.gz -C /export/install/</code><br/><br/><b>3.配置环境变量</b><br/><b>3.1 编辑文件</b><br/><code>vim /etc/profile.d/java.sh</code><br/><br/><b>3.2 将内容复制到文件中</b><br/>按i编辑<br/><br/><code>export JAVA_HOME=/export/install/jdk1.8.0_144</code></p><p><code>export PATH=$PATH:$JAVA_HOME/bin</code><br/><br/>按esc<br/>输入:wq 保存并退出<br/><br/><b>3.3 检查是否配置完成</b><br/>输入 jps<br/></p><pre><code class=\"Bash\"><xmp>jps: command not found</xmp></code></pre><p>表示未成功!<br/><br/><b>3.4 更新profile文件</b><br/><code>source /etc/profile</code><br/><br/><b>3.5 重新检查</b></p><p>输入jps<br/>如果出现数字表示安装成功!<br/></p><pre><code class=\"Bash\"><xmp>2296 Jps</xmp></code></pre><p><br/><b>4.切换版本(本地已有jdk时操作,没有请忽略!)</b><br/>先查看一下版本<br/><br/><code>java -version</code><br/><code>whereis java</code><br/><br/>查看这个目录<br/><br/><code>ll /usr/bin/java</code><br/><br/><br/>你会发现是一个软链接(类似于Windows的快捷方式)<br/>再查看一下<br/><br/><code>ll /etc/alternatives/java</code><br/><br/>你会看到指向的jdk1.7的bin里的java<br/>我们将这个软连接删除掉 再重新创建一个新的<br/><br/><code>rm -rf /etc/alternatives/java</code><br/><code>ln -s /export/install/jdk1.8.0_144/bin/java /etc/alternatives/java</code><br/><br/>再来查看一下版本</p><p><code>java -version</code><br/><br/>OK了!<br/><br/></p>','Gleam','2021-11-08 14:58:12','2021-11-08 14:58:12','Linux','Linux,JVM','http://localhost:9090/article/8a583286becb4493bc41642001f87a21',NULL),
(55,'linux安装nginx','linux下nginx的安装以及环境配置第一步：下载nginx压缩包在这里可以去nginx官网下载-&gt;点我下载nginx也可以直接使用wget命令下载，指令如下所示（请根据自己的需求进行下载）：wget -c https://nginx.org/download/nginx-1.10.1.tar.gz注意：这一步最好在自己的目标目录进行操作，我一般是把压缩包下载到/usr/local目录下。第二步：配置nginx安装所需的环境1. 安装gcc安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境。安装指令如下：yum install gcc-c++2. 安装PCRE pcre-develNginx的Rewrite模块和HTTP核心模块会使用到PCRE正则表达式语法。这里需要安装两个安装包pcre和pcre-devel。第一个安装包提供编译版本的库，而第二个提供开发阶段的头文件和编译项目的源代码。安装指令如下：yum install -y pcre pcre-devel3.安装zlibzlib库提供了开发人员的压缩算法，在Nginx的各种模块中需要使用gzip压缩。安装指令如下:yum install -y zlib zlib-devel4.安装Open SSLnginx不仅支持 http协议，还支持 https（即在 ssl 协议上传输 http），如果使用了 https，需要安装 OpenSSL 库。安装指令如下：yum install -y openssl openssl-devel第三步：解压nginx压缩包并安装将压缩包进行解压，解压指令还是写一下吧：tar -zxvf nginx-1.10.1.tar.gz解压之后，进入加压文件，即cd nginx-1.10.1。然后进行配置，推荐使用默认配置，直接./configure就好了，如下图所示：额外说明：如果需要开始https支持，这里请不要直接执行./configure，即不要直接执行该脚本，而是在该脚本后面加上SSL模块，请执行如下命令替代 ./confingure :./configure --with-http_ssl_module至于 --with-http_ssl_module 的意思，顾名思义可知是添加https支持。添加https支持也很简单，添加SSL证书并修改 nginx.conf 配置文件即可，如何修改不做介绍，自行百度~附带一个SSL证书免费申请网站第四步：编译安装nginx这里和redis的编译安装比较类似，首先在当前目录（/usr/local/nginx-1.10.1）进行编译。输入make即可make然后回车，如果编译出错，请检查是否前面的4个安装都没有问题。编译成功之后，就可以安装了，输入以下指令：make installok，安装成功。这时候返回上一级目录，就会发现多了nginx目录，接下来，启动nginx。第五步：启动nginx进入/usr/local/nginx/sbin目录，输入./nginx即可启动nginx./nginx关闭nginx./nginx -s quit  或者 ./nginx -s stop重启nginx./nginx -s reload查看nginx进程ps aux|grep nginx设置nginx开机启动，只需在rc.local增加启动代码即可。vim /etc/rc.local然后在底部增加/usr/local/nginx/sbin/nginx此外，进入/usr/local/nginx/conf目录可修改nginx的配置文件 --&gt;vim nginx.conf譬如修改域名以及端口啥的，在server里面进行修改即可。','<p><h2><b id=\"lp86u\">linux下nginx的安装以及环境配置</b></h2><br/><b>第一步：下载nginx压缩包</b><br/>在这里可以去nginx官网下载-&gt;点我下载nginx<br/>也可以直接使用wget命令下载，指令如下所示（请根据自己的需求进行下载）：</p><p><br/><code>wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</code><br/><br/>注意：这一步最好在自己的目标目录进行操作，我一般是把压缩包下载到/usr/local目录下。<br/><br/><b>第二步：配置nginx安装所需的环境</b><br/><br/><b>1. 安装gcc</b><br/><br/>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境。安装指令如下：<br/><br/><code>yum install gcc-c++</code><br/><br/><b>2. 安装PCRE pcre-devel</b><br/><br/>Nginx的Rewrite模块和HTTP核心模块会使用到PCRE正则表达式语法。这里需要安装两个安装包pcre和pcre-devel。第一个安装包提供编译版本的库，而第二个提供开发阶段的头文件和编译项目的源代码。安装指令如下：<br/><br/><code>yum install -y pcre pcre-devel</code><br/><br/><b>3.安装zlib</b><br/><br/>zlib库提供了开发人员的压缩算法，在Nginx的各种模块中需要使用gzip压缩。安装指令如下:<br/><br/><code>yum install -y zlib zlib-devel</code><br/><br/><b>4.安装Open SSL</b><br/><br/>nginx不仅支持 http协议，还支持 https（即在 ssl 协议上传输 http），如果使用了 https，需要安装 OpenSSL 库。安装指令如下：<br/><br/><code>yum install -y openssl openssl-devel</code><br/><br/><b>第三步：解压nginx压缩包并安装</b><br/><br/>将压缩包进行解压，解压指令还是写一下吧：<br/><br/><code>tar -zxvf nginx-1.10.1.tar.gz</code><br/><br/>解压之后，进入加压文件，即cd nginx-1.10.1。<br/>然后进行配置，推荐使用默认配置，直接./configure就好了，如下图所示：<br/><br/>额外说明：如果需要开始https支持，这里请不要直接执行./configure，即不要直接执行该脚本，而是在该脚本后面加上SSL模块，请执行如下命令替代 ./confingure :<br/><br/><code>./configure --with-http_ssl_module</code><br/><br/>至于 --with-http_ssl_module 的意思，顾名思义可知是添加https支持。<br/>添加https支持也很简单，添加SSL证书并修改 nginx.conf 配置文件即可，如何修改不做介绍，自行百度~<br/>附带一个SSL证书免费申请网站<br/><br/><b>第四步：编译安装nginx</b><br/>这里和redis的编译安装比较类似，首先在当前目录（/usr/local/nginx-1.10.1）进行编译。输入make即可<br/><br/><code>make</code><br/><br/>然后回车，如果编译出错，请检查是否前面的4个安装都没有问题。<br/>编译成功之后，就可以安装了，输入以下指令：<br/><br/><code>make install</code><br/><br/>ok，安装成功。<br/>这时候返回上一级目录，就会发现多了nginx目录，接下来，启动nginx。<br/><br/><b>第五步：启动nginx</b><br/><br/>进入/usr/local/nginx/sbin目录，输入./nginx即可启动nginx<br/><br/><code>./nginx</code><br/><br/>关闭nginx<br/><br/><code>./nginx -s quit  或者 ./nginx -s stop</code><br/><br/>重启nginx<br/><br/><code>./nginx -s reload</code><br/><br/>查看nginx进程<br/><br/><code>ps aux|grep nginx</code><br/><br/>设置nginx开机启动，只需在rc.local增加启动代码即可。<br/><br/><code>vim /etc/rc.local</code><br/><br/>然后在底部增加/usr/local/nginx/sbin/nginx<br/><br/><br/>此外，进入/usr/local/nginx/conf目录可修改nginx的配置文件 --&gt;vim nginx.conf</p><p><br/></p><p>譬如修改域名以及端口啥的，在server里面进行修改即可。<br/><br/></p>','Gleam','2021-11-08 15:06:30','2021-11-08 15:06:30','Linux','Linux,Nginx','http://localhost:9090/article/56c1a52add394f17a6d595052ab18f8f',NULL),
(57,'Redis常见应用场景','redis应用场景总结redis平时我们用到的地方蛮多的，下面就了解的应用场景做个总结：1、热点数据的缓存由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。2、限时业务的运用redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。3、计数器相关问题redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。4、排行榜相关问题关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。在奶茶活动中，我们需要展示各个部门的点赞排行榜， 所以我针对每个部门做了一个SortedSet,然后以用户的openid作为上面的username,以用户的点赞数作为上面的score, 然后针对每个用户做一个hash,通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。5、分布式锁 这个主要利用redis的setnx命令进行，setnx：\"set if not exists\"就是如果不存在则成功设置缓存同时返回1，否则返回0&nbsp;，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。6、延时操作 这个目前我做过相关测试，但是还没有运用到我们的实际项目中，下面我举个该特性的应用场景。 比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。 当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。7、分页、模糊搜索redis的set集合中提供了一个zrangebylex方法，语法如下：ZRANGEBYLEX key min max [LIMIT offset count]通过ZRANGEBYLEX zset - + LIMIT 0&nbsp;10 可以进行分页数据查询，其中-&nbsp;+表示获取全部数据zrangebylex key min max 这个就可以返回字典区间的数据，利用这个特性可以进行模糊查询功能，这个也是目前我在redis中发现的唯一一个支持对存储内容进行模糊查询的特性。前几天我通过这个特性，对学校数据进行了模拟测试，学校数据60万左右，响应时间在700ms左右，比mysql的like查询稍微快一点，但是由于它可以避免大量的数据库io操作，所以总体还是比直接mysql查询更利于系统的性能保障。8、点赞、好友等相互关系的存储Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 又或者在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。这个在奶茶活动中有运用，就是利用set存储用户之间的点赞关联的，另外在点赞前判断是否点赞过就利用了sismember方法，当时这个接口的响应时间控制在10毫秒内，十分高效。9、队列 由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。','<p>redis应用场景总结redis平时我们用到的地方蛮多的，下面就了解的应用场景做个总结：</p><h4><br/></h4><h4>1、热点数据的缓存</h4><p>由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。</p><h4><br/></h4><h4>2、限时业务的运用</h4><p>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p><h4><br/></h4><h4>3、计数器相关问题</h4><p>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p><h4><br/></h4><h4>4、排行榜相关问题</h4><p>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。</p><p>在奶茶活动中，我们需要展示各个部门的点赞排行榜， 所以我针对每个部门做了一个SortedSet,然后以用户的openid作为上面的username,以用户的点赞数作为上面的score, 然后针对每个用户做一个hash,通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p><h4><br/></h4><h4>5、分布式锁 </h4><p>这个主要利用redis的setnx命令进行，setnx：\"set if not exists\"就是如果不存在则成功设置缓存同时返回1，否则返回0&nbsp;，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p><p>当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。</p><h4><br/></h4><h4>6、延时操作 </h4><p>这个目前我做过相关测试，但是还没有运用到我们的实际项目中，下面我举个该特性的应用场景。 比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。 当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</p><h4><br/></h4><h4>7、分页、模糊搜索</h4><p>redis的set集合中提供了一个zrangebylex方法，语法如下：</p><p>ZRANGEBYLEX key min max [LIMIT offset count]</p><p>通过ZRANGEBYLEX zset - + LIMIT 0&nbsp;10 可以进行分页数据查询，其中-&nbsp;+表示获取全部数据</p><p>zrangebylex key min max 这个就可以返回字典区间的数据，利用这个特性可以进行模糊查询功能，这个也是目前我在redis中发现的唯一一个支持对存储内容进行模糊查询的特性。</p><p>前几天我通过这个特性，对学校数据进行了模拟测试，学校数据60万左右，响应时间在700ms左右，比mysql的like查询稍微快一点，但是由于它可以避免大量的数据库io操作，所以总体还是比直接mysql查询更利于系统的性能保障。</p><h4><br/></h4><h4>8、点赞、好友等相互关系的存储</h4><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 又或者在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</p><p>这个在奶茶活动中有运用，就是利用set存储用户之间的点赞关联的，另外在点赞前判断是否点赞过就利用了sismember方法，当时这个接口的响应时间控制在10毫秒内，十分高效。</p><h4><br/></h4><h4>9、队列 </h4><p>由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。</p>','Gleam','2021-11-08 18:53:38','2021-11-08 18:53:38','Redis','Redis','http://localhost:9090/article/6ff8485232a84672bb46ba3d8c55d0ff',NULL),
(58,'Shiro快速入门','一、架构要学习如何使用Shiro必须先从它的架构谈起，作为一款安全框架Shiro的设计相当精妙。Shiro的应用不依赖任何容器，它也可以在JavaSE下使用。但是最常用的环境还是JavaEE。下面以用户登录为例：（1）使用用户的登录信息创建令牌UsernamePasswordToken token = new UsernamePasswordToken(username, password);token可以理解为用户令牌，登录的过程被抽象为Shiro验证令牌是否具有合法身份以及相关权限。（2）执行登陆动作SecurityUtils.setSecurityManager(securityManager); // 注入SecurityManagerSubject subject = SecurityUtils.getSubject(); // 获取Subject单例对象subject.login(token); // 登陆Shiro的核心部分是SecurityManager，它负责安全认证与授权。Shiro本身已经实现了所有的细节，用户可以完全把它当做一个黑盒来使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。Subject是初学者比较难于理解的对象，很多人以为它可以等同于User，其实不然。Subject中文翻译：项目，而正确的理解也恰恰如此。它是你目前所设计的需要通过Shiro保护的项目的一个抽象概念。通过令牌（token）与项目（subject）的登陆（login）关系，Shiro保证了项目整体的安全。（3）判断用户Shiro本身无法知道所持有令牌的用户是否合法，因为除了项目的设计人员恐怕谁都无法得知。因此Realm是整个框架中为数不多的必须由设计者自行实现的模块，当然Shiro提供了多种实现的途径，本文只介绍最常见也最重要的一种实现方式——数据库查询。（4）两条重要的英文我在学习Shiro的过程中遇到的第一个障碍就是这两个对象的英文名称：AuthorizationInfo，AuthenticationInfo。不用怀疑自己的眼睛，它们确实长的很像，不但长的像，就连意思都十分近似。在解释它们前首先必须要描述一下Shiro对于安全用户的界定：和大多数操作系统一样。用户具有角色和权限两种最基本的属性。例如，我的Windows登陆名称是learnhow，它的角色是administrator，而administrator具有所有系统权限。这样learnhow自然就拥有了所有系统权限。那么其他人需要登录我的电脑怎么办，我可以开放一个guest角色，任何无法提供正确用户名与密码的未知用户都可以通过guest来登录，而系统对于guest角色开放的权限极其有限。同理，Shiro对用户的约束也采用了这样的方式。AuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合。如此一来，当设计人员对项目中的某一个url路径设置了只允许某个角色或具有某种权限才可以访问的控制约束的时候，Shiro就可以通过以上两个对象来判断。说到这里，大家可能还比较困惑。先不要着急，继续往后看就自然会明白了。二、实现Realm如何实现Realm是本文的重头戏，也是比较费事的部分。这里大家会接触到几个新鲜的概念：缓存机制、散列算法、加密算法。由于本文不会专门介绍这些概念，所以这里仅仅抛砖引玉的谈几点，能帮助大家更好的理解Shiro即可。（1）缓存机制Ehcache是很多Java项目中使用的缓存框架，Hibernate就是其中之一。它的本质就是将原本只能存储在内存中的数据通过算法保存到硬盘上，再根据需求依次取出。你可以把Ehcache理解为一个Map&lt;String,Object&gt;对象，通过put保存对象，再通过get取回对象。&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache name=\"shirocache\"&gt;    &lt;diskStore path=\"java.io.tmpdir\" /&gt;        &lt;cache name=\"passwordRetryCache\"           maxEntriesLocalHeap=\"2000\"           eternal=\"false\"           timeToIdleSeconds=\"1800\"           timeToLiveSeconds=\"0\"           overflowToDisk=\"false\"           statistics=\"true\"&gt;    &lt;/cache&gt;&lt;/ehcache&gt;以上是ehcache.xml文件的基础配置，timeToLiveSeconds为缓存的最大生存时间，timeToIdleSeconds为缓存的最大空闲时间，当eternal为false时ttl和tti才可以生效。更多配置的含义大家可以去网上查询。（2）散列算法与加密算法md5是本文会使用的散列算法，加密算法本文不会涉及。散列和加密本质上都是将一个Object变成一串无意义的字符串，不同点是经过散列的对象无法复原，是一个单向的过程。例如，对密码的加密通常就是使用散列算法，因此用户如果忘记密码只能通过修改而无法获取原始密码。但是对于信息的加密则是正规的加密算法，经过加密的信息是可以通过秘钥解密和还原。（3）用户注册请注意，虽然我们一直在谈论用户登录的安全性问题，但是说到用户登录首先就是用户注册。如何保证用户注册的信息不丢失，不泄密也是项目设计的重点。public class PasswordHelper {&nbsp;&nbsp;private RandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator();&nbsp; &nbsp;private String algorithmName = \"md5\";&nbsp;private final int hashIterations = 2;&nbsp;public void encryptPassword(User user) {        // User对象包含最基本的字段Username和Password&nbsp;&nbsp;user.setSalt(randomNumberGenerator.nextBytes().toHex());        // 将用户的注册密码经过散列算法替换成一个不可逆的新密码保存进数据，散列过程使用了盐&nbsp;&nbsp;String newPassword = new SimpleHash(algorithmName, user.getPassword(),&nbsp;&nbsp;ByteSource.Util.bytes(user.getCredentialsSalt()), hashIterations).toHex();&nbsp;&nbsp;user.setPassword(newPassword);&nbsp;&nbsp;}}如果你不清楚什么叫加盐可以忽略散列的过程，只要明白存储在数据库中的密码是根据户注册时填写的密码所产生的一个新字符串就可以了。经过散列后的密码替换用户注册时的密码，然后将User保存进数据库。剩下的工作就丢给UserService来处理。那么这样就带来了一个新问题，既然散列算法是无法复原的，当用户登录的时候使用当初注册时的密码，我们又应该如何判断？答案就是需要对用户密码再次以相同的算法散列运算一次，再同数据库中保存的字符串比较。（4）匹配CredentialsMatcher是一个接口，功能就是用来匹配用户登录使用的令牌和数据库中保存的用户信息是否匹配。当然它的功能不仅如此。本文要介绍的是这个接口的一个实现类：HashedCredentialsMatcherpublic class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher {    // 声明一个缓存接口，这个接口是Shiro缓存管理的一部分，它的具体实现可以通过外部容器注入&nbsp;&nbsp;private Cache passwordRetryCache;&nbsp;public RetryLimitHashedCredentialsMatcher(CacheManager cacheManager) {&nbsp;passwordRetryCache = cacheManager.getCache(\"passwordRetryCache\");}    @Override&nbsp;public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {&nbsp;&nbsp;String username = (String) token.getPrincipal();&nbsp;AtomicInteger retryCount = passwordRetryCache.get(username);&nbsp;if (retryCount == null) {&nbsp;retryCount = new AtomicInteger(0);&nbsp;passwordRetryCache.put(username, retryCount);&nbsp;}        // 自定义一个验证过程：当用户连续输入密码错误5次以上禁止用户登录一段时间&nbsp;if (retryCount.incrementAndGet() &gt; 5) {&nbsp;throw new ExcessiveAttemptsException();&nbsp;&nbsp;}&nbsp;boolean match = super.doCredentialsMatch(token, info);&nbsp;if (match) {&nbsp;passwordRetryCache.remove(username);&nbsp;}&nbsp;return match;&nbsp;}}可以看到，这个实现里设计人员仅仅是增加了一个不允许连续错误登录的判断。真正匹配的过程还是交给它的直接父类去完成。连续登录错误的判断依靠Ehcache缓存来实现。显然match返回true为匹配成功。（5）获取用户的角色和权限信息说了这么多才到我们的重点Realm，如果你已经理解了Shiro对于用户匹配和注册加密的全过程，真正理解Realm的实现反而比较简单。我们还得回到上文提及的两个非常类似的对象AuthorizationInfo和AuthenticationInfo。因为Realm就是提供这两个对象的地方。public class UserRealm extends AuthorizingRealm {    // 用户对应的角色信息与权限信息都保存在数据库中，通过UserService获取数据    private UserService userService = new UserServiceImpl();    /**     * 提供用户信息返回权限信息     */    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        String username = (String) principals.getPrimaryPrincipal();        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();        // 根据用户名查询当前用户拥有的角色        Set&lt;Role&gt; roles = userService.findRoles(username);        Set&lt;String&gt; roleNames = new HashSet&lt;String&gt;();        for (Role role : roles) {            roleNames.add(role.getRole());        }        // 将角色名称提供给info        authorizationInfo.setRoles(roleNames);        // 根据用户名查询当前用户权限        Set&lt;Permission&gt; permissions = userService.findPermissions(username);        Set&lt;String&gt; permissionNames = new HashSet&lt;String&gt;();        for (Permission permission : permissions) {            permissionNames.add(permission.getPermission());        }        // 将权限名称提供给info        authorizationInfo.setStringPermissions(permissionNames);        return authorizationInfo;    }    /**     * 提供账户信息返回认证信息     */    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String username = (String) token.getPrincipal();        User user = userService.findByUsername(username);        if (user == null) {            // 用户名不存在抛出异常            throw new UnknownAccountException();        }        if (user.getLocked() == 0) {            // 用户被管理员锁定抛出异常            throw new LockedAccountException();        }        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getUsername(),                user.getPassword(), ByteSource.Util.bytes(user.getCredentialsSalt()), getName());        return authenticationInfo;    }}根据Shiro的设计思路，用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多。在数据库中需要因此建立5张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键）。具体dao与service的实现本文不提供。总之结论就是，Shiro需要根据用户名和密码首先判断登录的用户是否合法，然后再对合法用户授权。而这个过程就是Realm的实现过程。（6）会话用户的一次登录即为一次会话，Shiro也可以代替Tomcat等容器管理会话。目的是当用户停留在某个页面长时间无动作的时候，再次对任何链接的访问都会被重定向到登录页面要求重新输入用户名和密码而不需要程序员在Servlet中不停的判断Session中是否包含User对象。启用Shiro会话管理的另一个用途是可以针对不同的模块采取不同的会话处理。以淘宝为例，用户注册淘宝以后可以选择记住用户名和密码。之后再次访问就无需登陆。但是如果你要访问支付宝或购物车等链接依然需要用户确认身份。当然，Shiro也可以创建使用容器提供的Session最为实现。三、与SpringMVC集成有了注册模块和Realm模块的支持，下面就是如何与SpringMVC集成开发。有过框架集成经验的同学一定知道，所谓的集成基本都是一堆xml文件的配置，Shiro也不例外。（1）配置前端过滤器先说一个题外话，Filter是过滤器，interceptor是拦截器。前者基于回调函数实现，必须依靠容器支持。因为需要容器装配好整条FilterChain并逐个调用。后者基于代理实现，属于AOP的范畴。如果希望在WEB环境中使用Shiro必须首先在web.xml文件中配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns=\"http://java.sun.com/xml/ns/javaee\"    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"    id=\"WebApp_ID\" version=\"3.0\"&gt;    &lt;display-name&gt;Shiro_Project&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;        &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!-- 将Shiro的配置文件交给Spring监听器初始化 --&gt;        &lt;param-value&gt;classpath:spring.xml,classpath:spring-shiro-web.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;context-param&gt;        &lt;param-name&gt;log4jConfigLoaction&lt;/param-name&gt;        &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!-- shiro配置 开始 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;        &lt;async-supported&gt;true&lt;/async-supported&gt;        &lt;init-param&gt;            &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;!-- shiro配置 结束 --&gt;&lt;/web-app&gt;熟悉Spring配置的同学可以重点看有绿字注释的部分，这里是使Shiro生效的关键。由于项目通过Spring管理，因此所有的配置原则上都是交给Spring。DelegatingFilterProxy的功能是通知Spring将所有的Filter交给ShiroFilter管理。接着在classpath路径下配置spring-shiro-web.xml文件&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans                            http://www.springframework.org/schema/beans/spring-beans-3.1.xsd                            http://www.springframework.org/schema/context                            http://www.springframework.org/schema/context/spring-context-3.1.xsd                            http://www.springframework.org/schema/mvc                            http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\"&gt;    &lt;!-- 缓存管理器 使用Ehcache实现 --&gt;    &lt;bean id=\"cacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"&gt;        &lt;property name=\"cacheManagerConfigFile\" value=\"classpath:ehcache.xml\" /&gt;    &lt;/bean&gt;    &lt;!-- 凭证匹配器 --&gt;    &lt;bean id=\"credentialsMatcher\" class=\"utils.RetryLimitHashedCredentialsMatcher\"&gt;        &lt;constructor-arg ref=\"cacheManager\" /&gt;        &lt;property name=\"hashAlgorithmName\" value=\"md5\" /&gt;        &lt;property name=\"hashIterations\" value=\"2\" /&gt;        &lt;property name=\"storedCredentialsHexEncoded\" value=\"true\" /&gt;    &lt;/bean&gt;    &lt;!-- Realm实现 --&gt;    &lt;bean id=\"userRealm\" class=\"utils.UserRealm\"&gt;        &lt;property name=\"credentialsMatcher\" ref=\"credentialsMatcher\" /&gt;    &lt;/bean&gt;    &lt;!-- 安全管理器 --&gt;    &lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt;        &lt;property name=\"realm\" ref=\"userRealm\" /&gt;    &lt;/bean&gt;    &lt;!-- Shiro的Web过滤器 --&gt;    &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt;        &lt;property name=\"securityManager\" ref=\"securityManager\" /&gt;        &lt;property name=\"loginUrl\" value=\"/\" /&gt;        &lt;property name=\"unauthorizedUrl\" value=\"/\" /&gt;        &lt;property name=\"filterChainDefinitions\"&gt;            &lt;value&gt;                /authc/admin = roles[admin]                /authc/** = authc                /** = anon            &lt;/value&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\" /&gt;&lt;/beans&gt;需要注意filterChainDefinitions过滤器中对于路径的配置是有顺序的，当找到匹配的条目之后容器不会再继续寻找。因此带有通配符的路径要放在后面。三条配置的含义是： /authc/admin需要用户有用admin权限、/authc/**用户必须登录才能访问、/**其他所有路径任何人都可以访问。说了这么多，大家一定关心在Spring中引入Shiro之后到底如何编写登录代码呢。@Controllerpublic class LoginController {    @Autowired    private UserService userService;    @RequestMapping(\"login\")    public ModelAndView login(@RequestParam(\"username\") String username, @RequestParam(\"password\") String password) {        UsernamePasswordToken token = new UsernamePasswordToken(username, password);        Subject subject = SecurityUtils.getSubject();        try {            subject.login(token);        } catch (IncorrectCredentialsException ice) {            // 捕获密码错误异常            ModelAndView mv = new ModelAndView(\"error\");            mv.addObject(\"message\", \"password error!\");            return mv;        } catch (UnknownAccountException uae) {            // 捕获未知用户名异常            ModelAndView mv = new ModelAndView(\"error\");            mv.addObject(\"message\", \"username error!\");            return mv;        } catch (ExcessiveAttemptsException eae) {            // 捕获错误登录过多的异常            ModelAndView mv = new ModelAndView(\"error\");            mv.addObject(\"message\", \"times error\");            return mv;        }        User user = userService.findByUsername(username);        subject.getSession().setAttribute(\"user\", user);        return new ModelAndView(\"success\");    }}登录完成以后，当前用户信息被保存进Session。这个Session是通过Shiro管理的会话对象，要获取依然必须通过Shiro。传统的Session中不存在User对象。@Controller@RequestMapping(\"authc\")public class AuthcController {    // /authc/** = authc 任何通过表单登录的用户都可以访问    @RequestMapping(\"anyuser\")    public ModelAndView anyuser() {        Subject subject = SecurityUtils.getSubject();        User user = (User) subject.getSession().getAttribute(\"user\");        System.out.println(user);        return new ModelAndView(\"inner\");    }    // /authc/admin = user[admin] 只有具备admin角色的用户才可以访问，否则请求将被重定向至登录界面    @RequestMapping(\"admin\")    public ModelAndView admin() {        Subject subject = SecurityUtils.getSubject();        User user = (User) subject.getSession().getAttribute(\"user\");        System.out.println(user);        return new ModelAndView(\"inner\");    }}','<p><h2><b id=\"cprfk\">一、架构</b></h2><br/>要学习如何使用Shiro必须先从它的架构谈起，作为一款安全框架Shiro的设计相当精妙。Shiro的应用不依赖任何容器，它也可以在JavaSE下使用。但是最常用的环境还是JavaEE。下面以用户登录为例：<br/><br/><b>（1）使用用户的登录信息创建令牌</b><br/><br/><code>UsernamePasswordToken token = new UsernamePasswordToken(username, password);</code><br/><br/></p><p>token可以理解为用户令牌，登录的过程被抽象为Shiro验证令牌是否具有合法身份以及相关权限。<br/><br/><b>（2）执行登陆动作</b><br/><code>SecurityUtils.setSecurityManager(securityManager); // 注入Security</code></p><p><code>ManagerSubject subject = SecurityUtils.getSubject(); // 获取Subject单例对象</code></p><p><code>subject.login(token); // 登陆</code><br/><br/></p><p>Shiro的核心部分是SecurityManager，它负责安全认证与授权。Shiro本身已经实现了所有的细节，用户可以完全把它当做一个黑盒来使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。Subject是初学者比较难于理解的对象，很多人以为它可以等同于User，其实不然。Subject中文翻译：项目，而正确的理解也恰恰如此。它是你目前所设计的需要通过Shiro保护的项目的一个抽象概念。通过令牌（token）与项目（subject）的登陆（login）关系，Shiro保证了项目整体的安全。<br/><br/><b>（3）判断用户</b><br/><br/>Shiro本身无法知道所持有令牌的用户是否合法，因为除了项目的设计人员恐怕谁都无法得知。因此Realm是整个框架中为数不多的必须由设计者自行实现的模块，当然Shiro提供了多种实现的途径，本文只介绍最常见也最重要的一种实现方式——数据库查询。<br/><br/><b>（4）两条重要的英文</b><br/><br/>我在学习Shiro的过程中遇到的第一个障碍就是这两个对象的英文名称：AuthorizationInfo，AuthenticationInfo。不用怀疑自己的眼睛，它们确实长的很像，不但长的像，就连意思都十分近似。<br/><br/>在解释它们前首先必须要描述一下Shiro对于安全用户的界定：和大多数操作系统一样。用户具有角色和权限两种最基本的属性。例如，我的Windows登陆名称是learnhow，它的角色是administrator，而administrator具有所有系统权限。这样learnhow自然就拥有了所有系统权限。那么其他人需要登录我的电脑怎么办，我可以开放一个guest角色，任何无法提供正确用户名与密码的未知用户都可以通过guest来登录，而系统对于guest角色开放的权限极其有限。<br/><br/>同理，Shiro对用户的约束也采用了这样的方式。AuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合。如此一来，当设计人员对项目中的某一个url路径设置了只允许某个角色或具有某种权限才可以访问的控制约束的时候，Shiro就可以通过以上两个对象来判断。说到这里，大家可能还比较困惑。先不要着急，继续往后看就自然会明白了。<br/><br/><h2 id=\"16y6q\">二、实现Realm</h2><br/>如何实现Realm是本文的重头戏，也是比较费事的部分。这里大家会接触到几个新鲜的概念：缓存机制、散列算法、加密算法。由于本文不会专门介绍这些概念，所以这里仅仅抛砖引玉的谈几点，能帮助大家更好的理解Shiro即可。<br/><br/><b>（1）缓存机制</b><br/><br/>Ehcache是很多Java项目中使用的缓存框架，Hibernate就是其中之一。它的本质就是将原本只能存储在内存中的数据通过算法保存到硬盘上，再根据需求依次取出。你可以把Ehcache理解为一个Map&lt;String,Object&gt;对象，通过put保存对象，再通过get取回对象。<br/><br/>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br/>&lt;ehcache name=\"shirocache\"&gt;<br/>    &lt;diskStore path=\"java.io.tmpdir\" /&gt;<br/>    <br/>    &lt;cache name=\"passwordRetryCache\"<br/>           maxEntriesLocalHeap=\"2000\"<br/>           eternal=\"false\"<br/>           timeToIdleSeconds=\"1800\"<br/>           timeToLiveSeconds=\"0\"<br/>           overflowToDisk=\"false\"<br/>           statistics=\"true\"&gt;<br/>    &lt;/cache&gt;<br/>&lt;/ehcache&gt;<br/><br/>以上是ehcache.xml文件的基础配置，timeToLiveSeconds为缓存的最大生存时间，timeToIdleSeconds为缓存的最大空闲时间，当eternal为false时ttl和tti才可以生效。更多配置的含义大家可以去网上查询。<br/><br/><b>（2）散列算法与加密算法</b><br/><br/>md5是本文会使用的散列算法，加密算法本文不会涉及。散列和加密本质上都是将一个Object变成一串无意义的字符串，不同点是经过散列的对象无法复原，是一个单向的过程。例如，对密码的加密通常就是使用散列算法，因此用户如果忘记密码只能通过修改而无法获取原始密码。但是对于信息的加密则是正规的加密算法，经过加密的信息是可以通过秘钥解密和还原。<br/><br/><b>（3）用户注册</b><br/><br/>请注意，虽然我们一直在谈论用户登录的安全性问题，但是说到用户登录首先就是用户注册。如何保证用户注册的信息不丢失，不泄密也是项目设计的重点。<br/><br/><code>public class PasswordHelper {&nbsp;</code></p><p><code>&nbsp;private RandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator();&nbsp; &nbsp;private String algorithmName = \"md5\";</code></p><p><code>&nbsp;private final int hashIterations = 2;</code></p><p><code>&nbsp;public void encryptPassword(User user) {        // User对象包含最基本的字段Username和Password&nbsp;</code></p><p><code>&nbsp;user.setSalt(randomNumberGenerator.nextBytes().toHex());        // 将用户的注册密码经过散列算法替换成一个不可逆的新密码保存进数据，散列过程使用了盐&nbsp;</code></p><p><code>&nbsp;String newPassword = new SimpleHash(algorithmName, user.getPassword(),&nbsp;</code></p><p><code>&nbsp;ByteSource.Util.bytes(user.getCredentialsSalt()), hashIterations).toHex();&nbsp;</code></p><p><code>&nbsp;user.setPassword(newPassword);&nbsp;</code></p><p><code>&nbsp;}</code></p><p><code>}</code><br/><br/>如果你不清楚什么叫加盐可以忽略散列的过程，只要明白存储在数据库中的密码是根据户注册时填写的密码所产生的一个新字符串就可以了。经过散列后的密码替换用户注册时的密码，然后将User保存进数据库。剩下的工作就丢给UserService来处理。<br/><br/>那么这样就带来了一个新问题，既然散列算法是无法复原的，当用户登录的时候使用当初注册时的密码，我们又应该如何判断？答案就是需要对用户密码再次以相同的算法散列运算一次，再同数据库中保存的字符串比较。<br/><br/><b>（4）匹配</b><br/><br/>CredentialsMatcher是一个接口，功能就是用来匹配用户登录使用的令牌和数据库中保存的用户信息是否匹配。当然它的功能不仅如此。本文要介绍的是这个接口的一个实现类：HashedCredentialsMatcher<br/><br/><code>public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher {    // 声明一个缓存接口，这个接口是Shiro缓存管理的一部分，它的具体实现可以通过外部容器注入&nbsp;</code></p><p><code>&nbsp;private Cache<string, atomicinteger=\"\"> passwordRetryCache;</string,></code></p><p><code><string, atomicinteger=\"\">&nbsp;public RetryLimitHashedCredentialsMatcher(CacheManager cacheManager) {</string,></code></p><p><code><string, atomicinteger=\"\">&nbsp;passwordRetryCache = cacheManager.getCache(\"passwordRetryCache\");</string,></code></p><p><code><string, atomicinteger=\"\">}</string,></code><br/><code>    @Override</code></p><p><code>&nbsp;public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {&nbsp;</code></p><p><code>&nbsp;String username = (String) token.getPrincipal();</code></p><p><code>&nbsp;AtomicInteger retryCount = passwordRetryCache.get(username);</code></p><p><code>&nbsp;if (retryCount == null) {</code></p><p><code>&nbsp;retryCount = new AtomicInteger(0);</code></p><p><code>&nbsp;passwordRetryCache.put(username, retryCount);</code></p><p><code>&nbsp;}        // 自定义一个验证过程：当用户连续输入密码错误5次以上禁止用户登录一段时间</code></p><p><code>&nbsp;if (retryCount.incrementAndGet() &gt; 5) {</code></p><p><code>&nbsp;throw new ExcessiveAttemptsException();&nbsp;</code></p><p><code>&nbsp;}</code></p><p><code>&nbsp;boolean match = super.doCredentialsMatch(token, info);</code></p><p><code>&nbsp;if (match) {</code></p><p><code>&nbsp;passwordRetryCache.remove(username);</code></p><p><code>&nbsp;}</code></p><p><code>&nbsp;return match;</code></p><p><code>&nbsp;}</code></p><p><code>}</code><br/><br/>可以看到，这个实现里设计人员仅仅是增加了一个不允许连续错误登录的判断。真正匹配的过程还是交给它的直接父类去完成。连续登录错误的判断依靠Ehcache缓存来实现。显然match返回true为匹配成功。<br/><br/><b>（5）获取用户的角色和权限信息</b><br/><br/>说了这么多才到我们的重点Realm，如果你已经理解了Shiro对于用户匹配和注册加密的全过程，真正理解Realm的实现反而比较简单。我们还得回到上文提及的两个非常类似的对象AuthorizationInfo和AuthenticationInfo。因为Realm就是提供这两个对象的地方。<br/><br/><br/>public class UserRealm extends AuthorizingRealm {<br/>    // 用户对应的角色信息与权限信息都保存在数据库中，通过UserService获取数据<br/>    private UserService userService = new UserServiceImpl();<br/><br/>    /**<br/>     * 提供用户信息返回权限信息<br/>     */<br/>    @Override<br/>    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {<br/>        String username = (String) principals.getPrimaryPrincipal();<br/>        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();<br/>        // 根据用户名查询当前用户拥有的角色<br/>        Set&lt;Role&gt; roles = userService.findRoles(username);<br/>        Set&lt;String&gt; roleNames = new HashSet&lt;String&gt;();<br/>        for (Role role : roles) {<br/>            roleNames.add(role.getRole());<br/>        }<br/>        // 将角色名称提供给info<br/>        authorizationInfo.setRoles(roleNames);<br/>        // 根据用户名查询当前用户权限<br/>        Set&lt;Permission&gt; permissions = userService.findPermissions(username);<br/>        Set&lt;String&gt; permissionNames = new HashSet&lt;String&gt;();<br/>        for (Permission permission : permissions) {<br/>            permissionNames.add(permission.getPermission());<br/>        }<br/>        // 将权限名称提供给info<br/>        authorizationInfo.setStringPermissions(permissionNames);<br/><br/>        return authorizationInfo;<br/>    }<br/><br/>    /**<br/>     * 提供账户信息返回认证信息<br/>     */<br/>    @Override<br/>    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {<br/>        String username = (String) token.getPrincipal();<br/>        User user = userService.findByUsername(username);<br/>        if (user == null) {<br/>            // 用户名不存在抛出异常<br/>            throw new UnknownAccountException();<br/>        }<br/>        if (user.getLocked() == 0) {<br/>            // 用户被管理员锁定抛出异常<br/>            throw new LockedAccountException();<br/>        }<br/>        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getUsername(),<br/>                user.getPassword(), ByteSource.Util.bytes(user.getCredentialsSalt()), getName());<br/>        return authenticationInfo;<br/>    }<br/>}<br/><br/>根据Shiro的设计思路，用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多。在数据库中需要因此建立5张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键）。具体dao与service的实现本文不提供。总之结论就是，Shiro需要根据用户名和密码首先判断登录的用户是否合法，然后再对合法用户授权。而这个过程就是Realm的实现过程。<br/><br/><b>（6）会话</b><br/><br/>用户的一次登录即为一次会话，Shiro也可以代替Tomcat等容器管理会话。目的是当用户停留在某个页面长时间无动作的时候，再次对任何链接的访问都会被重定向到登录页面要求重新输入用户名和密码而不需要程序员在Servlet中不停的判断Session中是否包含User对象。启用Shiro会话管理的另一个用途是可以针对不同的模块采取不同的会话处理。以淘宝为例，用户注册淘宝以后可以选择记住用户名和密码。之后再次访问就无需登陆。但是如果你要访问支付宝或购物车等链接依然需要用户确认身份。当然，Shiro也可以创建使用容器提供的Session最为实现。<br/><h2 id=\"vnpsv\"><br/>三、与SpringMVC集成</h2><br/>有了注册模块和Realm模块的支持，下面就是如何与SpringMVC集成开发。有过框架集成经验的同学一定知道，所谓的集成基本都是一堆xml文件的配置，Shiro也不例外。<br/><br/><b>（1）配置前端过滤器</b><br/><br/>先说一个题外话，Filter是过滤器，interceptor是拦截器。前者基于回调函数实现，必须依靠容器支持。因为需要容器装配好整条FilterChain并逐个调用。后者基于代理实现，属于AOP的范畴。<br/><br/>如果希望在WEB环境中使用Shiro必须首先在web.xml文件中配置<br/><br/>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br/>&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"<br/>    xmlns=\"http://java.sun.com/xml/ns/javaee\"<br/>    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"<br/>    id=\"WebApp_ID\" version=\"3.0\"&gt;<br/>    &lt;display-name&gt;Shiro_Project&lt;/display-name&gt;<br/>    &lt;welcome-file-list&gt;<br/>        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;<br/>    &lt;/welcome-file-list&gt;<br/>    &lt;servlet&gt;<br/>        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;<br/>        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;<br/>        &lt;init-param&gt;<br/>            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br/>            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;<br/>        &lt;/init-param&gt;<br/>        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br/>        &lt;async-supported&gt;true&lt;/async-supported&gt;<br/>    &lt;/servlet&gt;<br/>    &lt;servlet-mapping&gt;<br/>        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;<br/>        &lt;url-pattern&gt;/&lt;/url-pattern&gt;<br/>    &lt;/servlet-mapping&gt;<br/>    &lt;listener&gt;<br/>        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;<br/>    &lt;/listener&gt;<br/>    &lt;listener&gt;<br/>        &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;<br/>    &lt;/listener&gt;<br/>    &lt;context-param&gt;<br/>        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br/>        &lt;!-- 将Shiro的配置文件交给Spring监听器初始化 --&gt;<br/>        &lt;param-value&gt;classpath:spring.xml,classpath:spring-shiro-web.xml&lt;/param-value&gt;<br/>    &lt;/context-param&gt;<br/>    &lt;context-param&gt;<br/>        &lt;param-name&gt;log4jConfigLoaction&lt;/param-name&gt;<br/>        &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt;<br/>    &lt;/context-param&gt;<br/>    &lt;!-- shiro配置 开始 --&gt;<br/>    &lt;filter&gt;<br/>        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;<br/>        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;<br/>        &lt;async-supported&gt;true&lt;/async-supported&gt;<br/>        &lt;init-param&gt;<br/>            &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;<br/>            &lt;param-value&gt;true&lt;/param-value&gt;<br/>        &lt;/init-param&gt;<br/>    &lt;/filter&gt;<br/>    &lt;filter-mapping&gt;<br/>        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;<br/>        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;<br/>    &lt;/filter-mapping&gt;<br/>    &lt;!-- shiro配置 结束 --&gt;<br/>&lt;/web-app&gt;<br/><br/>熟悉Spring配置的同学可以重点看有绿字注释的部分，这里是使Shiro生效的关键。由于项目通过Spring管理，因此所有的配置原则上都是交给Spring。DelegatingFilterProxy的功能是通知Spring将所有的Filter交给ShiroFilter管理。<br/><br/>接着在classpath路径下配置spring-shiro-web.xml文件<br/><br/>&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"<br/>    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"<br/>    xmlns:context=\"http://www.springframework.org/schema/context\"<br/>    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"<br/>    xsi:schemaLocation=\"http://www.springframework.org/schema/beans    <br/>                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    <br/>                        http://www.springframework.org/schema/context    <br/>                        http://www.springframework.org/schema/context/spring-context-3.1.xsd    <br/>                        http://www.springframework.org/schema/mvc    <br/>                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\"&gt;<br/><br/>    &lt;!-- 缓存管理器 使用Ehcache实现 --&gt;<br/>    &lt;bean id=\"cacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"&gt;<br/>        &lt;property name=\"cacheManagerConfigFile\" value=\"classpath:ehcache.xml\" /&gt;<br/>    &lt;/bean&gt;<br/><br/>    &lt;!-- 凭证匹配器 --&gt;<br/>    &lt;bean id=\"credentialsMatcher\" class=\"utils.RetryLimitHashedCredentialsMatcher\"&gt;<br/>        &lt;constructor-arg ref=\"cacheManager\" /&gt;<br/>        &lt;property name=\"hashAlgorithmName\" value=\"md5\" /&gt;<br/>        &lt;property name=\"hashIterations\" value=\"2\" /&gt;<br/>        &lt;property name=\"storedCredentialsHexEncoded\" value=\"true\" /&gt;<br/>    &lt;/bean&gt;<br/><br/>    &lt;!-- Realm实现 --&gt;<br/>    &lt;bean id=\"userRealm\" class=\"utils.UserRealm\"&gt;<br/>        &lt;property name=\"credentialsMatcher\" ref=\"credentialsMatcher\" /&gt;<br/>    &lt;/bean&gt;<br/><br/>    &lt;!-- 安全管理器 --&gt;<br/>    &lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt;<br/>        &lt;property name=\"realm\" ref=\"userRealm\" /&gt;<br/>    &lt;/bean&gt;<br/><br/>    &lt;!-- Shiro的Web过滤器 --&gt;<br/>    &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt;<br/>        &lt;property name=\"securityManager\" ref=\"securityManager\" /&gt;<br/>        &lt;property name=\"loginUrl\" value=\"/\" /&gt;<br/>        &lt;property name=\"unauthorizedUrl\" value=\"/\" /&gt;<br/>        &lt;property name=\"filterChainDefinitions\"&gt;<br/>            &lt;value&gt;<br/>                /authc/admin = roles[admin]<br/>                /authc/** = authc<br/>                /** = anon<br/>            &lt;/value&gt;<br/>        &lt;/property&gt;<br/>    &lt;/bean&gt;<br/><br/>    &lt;bean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\" /&gt;<br/>&lt;/beans&gt;<br/><br/>需要注意filterChainDefinitions过滤器中对于路径的配置是有顺序的，当找到匹配的条目之后容器不会再继续寻找。因此带有通配符的路径要放在后面。三条配置的含义是： /authc/admin需要用户有用admin权限、/authc/**用户必须登录才能访问、/**其他所有路径任何人都可以访问。<br/><br/>说了这么多，大家一定关心在Spring中引入Shiro之后到底如何编写登录代码呢。<br/><br/>@Controller<br/>public class LoginController {<br/>    @Autowired<br/>    private UserService userService;<br/><br/>    @RequestMapping(\"login\")<br/>    public ModelAndView login(@RequestParam(\"username\") String username, @RequestParam(\"password\") String password) {<br/>        UsernamePasswordToken token = new UsernamePasswordToken(username, password);<br/>        Subject subject = SecurityUtils.getSubject();<br/>        try {<br/>            subject.login(token);<br/>        } catch (IncorrectCredentialsException ice) {<br/>            // 捕获密码错误异常<br/>            ModelAndView mv = new ModelAndView(\"error\");<br/>            mv.addObject(\"message\", \"password error!\");<br/>            return mv;<br/>        } catch (UnknownAccountException uae) {<br/>            // 捕获未知用户名异常<br/>            ModelAndView mv = new ModelAndView(\"error\");<br/>            mv.addObject(\"message\", \"username error!\");<br/>            return mv;<br/>        } catch (ExcessiveAttemptsException eae) {<br/>            // 捕获错误登录过多的异常<br/>            ModelAndView mv = new ModelAndView(\"error\");<br/>            mv.addObject(\"message\", \"times error\");<br/>            return mv;<br/>        }<br/>        User user = userService.findByUsername(username);<br/>        subject.getSession().setAttribute(\"user\", user);<br/>        return new ModelAndView(\"success\");<br/>    }<br/>}<br/><br/>登录完成以后，当前用户信息被保存进Session。这个Session是通过Shiro管理的会话对象，要获取依然必须通过Shiro。传统的Session中不存在User对象。<br/><br/>@Controller<br/>@RequestMapping(\"authc\")<br/>public class AuthcController {<br/>    // /authc/** = authc 任何通过表单登录的用户都可以访问<br/>    @RequestMapping(\"anyuser\")<br/>    public ModelAndView anyuser() {<br/>        Subject subject = SecurityUtils.getSubject();<br/>        User user = (User) subject.getSession().getAttribute(\"user\");<br/>        System.out.println(user);<br/>        return new ModelAndView(\"inner\");<br/>    }<br/><br/>    // /authc/admin = user[admin] 只有具备admin角色的用户才可以访问，否则请求将被重定向至登录界面<br/>    @RequestMapping(\"admin\")<br/>    public ModelAndView admin() {<br/>        Subject subject = SecurityUtils.getSubject();<br/>        User user = (User) subject.getSession().getAttribute(\"user\");<br/>        System.out.println(user);<br/>        return new ModelAndView(\"inner\");<br/>    }<br/>}</p>','Gleam','2021-11-08 19:14:46','2021-11-08 19:14:46','Shiro','Spring,Springmvc,Springboot,Shiro','http://localhost:9090/article/60938dbcf33a495ca0f674647bced475','false');

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `userid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `password` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `role` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT 'user',
  `perms` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT 'use',
  `status` tinyint(1) DEFAULT '1',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `token` varchar(999) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `deleted` int DEFAULT '0' COMMENT '逻辑删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

/*Data for the table `user` */

insert  into `user`(`id`,`userid`,`password`,`role`,`perms`,`status`,`email`,`token`,`deleted`) values 
(1,'Gleam','136189','admin','manage',1,'lw666@163.com','eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJ1c2VyaWQiOiJHbGVhbSIsInJvbGUiOiJhZG1pbiIsInBlcm1zIjoibWFuYWdlIiwic3ViIjoiaGVsbG8iLCJpYXQiOjE2MzcyMzQ1MjYsImV4cCI6MTYzNzMyMDkyNiwianRpIjoiZmQ5NDVlYWUtMGY3NS00MjdmLWI0MjctMDg4MGVjM2ZmMWRjIn0.QeWQM20lvyqb4u6MgT5CmRDH4h7x7JifgUnPYzYqU5hbczlxfRPO2npcHZQ9eMGmCNRjciHP6-tNYEpT70vtMQ',0),
(2,'admin','123','admin','manage',0,NULL,'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJ1c2VyaWQiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiIsInBlcm1zIjoibWFuYWdlIiwic3ViIjoiaGVsbG8iLCJpYXQiOjE2MzY4NTc5NTAsImV4cCI6MTYzNjk0NDM1MCwianRpIjoiMjc1Y2RiMzMtMzc4MS00NjJjLWIzODEtZjI3ODFjOWY0NGMyIn0.eVq97C2EYVP6Z0M5mSYankhQckceDz3uzOPjWh01SUEcXmx1C1gnw6m9zSP4yIHYjXIKG_r-UFPurtP4p2u5rQ',0),
(3,'user','123','user','use',0,NULL,'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJ1c2VyaWQiOiJ1c2VyIiwicm9sZSI6InVzZXIiLCJwZXJtcyI6InVzZSIsInN1YiI6ImhlbGxvIiwiaWF0IjoxNjM2ODA3NTI4LCJleHAiOjE2MzY4OTM5MjgsImp0aSI6ImVmYTUzYmIxLTM4YTItNDA0Yy1hZWIzLTgyNmYzZGYwNTkxYiJ9.SS-_-sIXSdya2HAlpf4YvxMordkUwjn3UvavnbUCziM9LipOeZ6NneZCmCoGt2n4spysFT9UhwG4l8C8A1PO-g',0),
(6,'lw666','123','user','use',1,NULL,'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJ1c2VyaWQiOiJsdzY2NiIsInJvbGUiOiJ1c2VyIiwicGVybXMiOiJ1c2UiLCJzdWIiOiJoZWxsbyIsImlhdCI6MTYzNjk3NTU3NSwiZXhwIjoxNjM3MDYxOTc1LCJqdGkiOiI2MTc0ZjY1Ni0wYzE0LTRjZTYtYjQxMy1lYTQzZTg2MDlhYTAifQ.rRTmMieqClxwMX542Kwf1iufqjEHffJ46iTy5I1M0-oJYdtuM-v2XOxucEbR-BrOcqxna-8Z6rACgSkK3Pg0oA',0),
(7,'test','123','user','use',1,NULL,'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJ1c2VyaWQiOiJ0ZXN0Iiwicm9sZSI6InVzZXIiLCJwZXJtcyI6InVzZSIsInN1YiI6ImhlbGxvIiwiaWF0IjoxNjM3MjAzMjgzLCJleHAiOjE2MzcyODk2ODMsImp0aSI6IjIzYTMyYjJlLTdmYzktNDMyZi1hMGEwLTkyYWU4MTg2MjRhMSJ9.4nDXkiVOejvqy5F5EsQjVedMOoSJabmRgvWveKLgNjfruW2gN2zp9AnYBgJYA5Ng5LtY19mwuxr3u2FX2bS3wg',0),
(8,'dele','123','user','use',1,NULL,'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJ1c2VyaWQiOiJkZWxlIiwicm9sZSI6InVzZXIiLCJwZXJtcyI6InVzZSIsInN1YiI6ImhlbGxvIiwiaWF0IjoxNjM3MjM2NDc2LCJleHAiOjE2MzczMjI4NzYsImp0aSI6IjMwYjEyNWY5LWIyNWYtNGU1Yi1hZmQ2LWQ1YzdhYzI2OGRjMSJ9.hULe1_mTGkqM-XTELjpQNp0iCFSB87RHfeuuCn7EqeJB95xpgwWgKKi0FLSkWIdcShbuvcUkMt0OBp57cs9VYQ',1);

/*Table structure for table `userinfo` */

DROP TABLE IF EXISTS `userinfo`;

CREATE TABLE `userinfo` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `userid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '账号',
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '用户名',
  `role` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '普通用户' COMMENT '角色',
  `avatar` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT 'https://cube.elemecdn.com/0/88/03b0d39583f48206768a7534e55bcpng.png' COMMENT '头像',
  `sex` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT '未选择' COMMENT '性别',
  `introduction` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT '未填写' COMMENT '简介',
  `birth` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT '未选择' COMMENT '出生日期',
  `address` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT '未选择' COMMENT '所在地区',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

/*Data for the table `userinfo` */

insert  into `userinfo`(`id`,`userid`,`username`,`role`,`avatar`,`sex`,`introduction`,`birth`,`address`) values 
(1,'Gleam','普通上班族','超级管理员','http://localhost:9090/userinfo/ff1ff1500e974ce2ab3b4a0bbfb4f560','男','这个人很懒，还没有留下个人简介。','2001年03月11日','江苏省苏州市常熟市'),
(2,'admin','小明','管理员','https://cube.elemecdn.com/0/88/03b0d39583f48206768a7534e55bcpng.png','未选择','未填写','未选择','未选择'),
(3,'user','张三','普通用户','https://cube.elemecdn.com/0/88/03b0d39583f48206768a7534e55bcpng.png','未选择','未填写','未选择','未选择'),
(6,'lw666','博客用户_cjq2x','普通用户','https://cube.elemecdn.com/0/88/03b0d39583f48206768a7534e55bcpng.png','未选择','未填写','未选择','未选择'),
(7,'test','博客用户_aVuC5','普通用户','https://cube.elemecdn.com/0/88/03b0d39583f48206768a7534e55bcpng.png','未选择','未填写','未选择','未选择'),
(8,'dele','博客用户_13Pwq','普通用户','https://cube.elemecdn.com/0/88/03b0d39583f48206768a7534e55bcpng.png','未选择','未填写','未选择','未选择');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
